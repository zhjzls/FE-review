<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>创建对象</h1>
    <p>使用Object构造函数或对象字面量创建对象时，有一个共同的问题： 出现大量重复代码。 由此引出一下几种创建对象的方式：</p>
    <ol>
        <li>工厂模式
            <p>
                优点： 解决了创建多个相似对象的问题。
            </p>
            <p>
                缺点： 未解决对象识别的问题。（一个对象的类型无法得知）
            </p>
        </li>
        <li>构造函数模式
            <p>
                创建实例，必须使用new 操作符。 调用构造函数会经历4个步骤：
            <ol>
                <li>创建一个新对象</li>
                <li>把构造函数的作用于赋值给新对象</li>
                <li>给新对象赋值</li>
                <li>返回新对象</li>
            </ol>
            </p>
            <p>可以通过instanceof 判断当前实例是哪种类型的构造函数</p>

            <p>优点： 弥补了工厂模式不识别对象的缺点</p>
            <p>缺点： 在初始化实例时，每个方法都要在实例上重新创建一遍。
                以构造函数方式创建对象， 不同实例上的同名函数不相等。
            </p>
        </li>
        <li>原型模式
            构造函数的原型属性指向一个对象， 这个对象中的属性和方法，可以被该构造函数的所有实例共有。
            <ul>
                原型对象
                通过hasOwnProperty 和 in 可以判断属性是在对象中，还是存在原型中
                <li>
                    理解原型对象
                    无论什么时候，只要创建了一个新函数，就会根据特定规则为该函数创建一个prototype 属性， 这个属性指向函数的原型对象。
                    默认情况下， 所有原型对象会自动获得一个constructor属性，该属性包含一个指向 prototype所属的函数的指针。
                    <p>
                        创建自定义构造函数并创建一个新实例后，该实例的内部将包含一个指针([[prototype]], 浏览器中， 可以通过 __proto__来读取)，指向构造函数的原型对象。
                    </p>
                </li>

                <p>
                    优点： 解决了属性方法重复创建的问题， 同时，可以识别实例的构造类型。
                </p>
                <p>
                    缺点：1. 省略了为构造函数传递初始化参数的环节。
                </p>
                <p>
                    2. 原型上所有的属性都是共享的， 对于基本类型的属性，可以通过在实例上添加一个同名属性，从而屏蔽原型上对应的属性。 但是对应引用类型值的熟悉，就会导致一处改变，全局生效，会影响到其他实例的数据。
                </p>

            </ul>
        </li>
        <li>
            组合使用构造函数模式和原型模式
            <p>优点: 每个实例都有自己的实例属性的副本， 同时，又共享对方法的引用。此外，还支持向构造函数传递参数。</p>
            <p>ps: 通过向构造函数传递参数，给每个实例定义不同的属性值； 通过原型共享对方法的引用；</p>
            <p>缺点： 暂无</p>
        </li>
        <li>
            动态原型模式
            <p>在组合继承的基础上，减少共享函数的声明（共享方法只需在原型对象上添加一次就能达到复用的目的了，可以减少不必要代码的执行）</p>
            <p>优点： 完美</p>
            <p>确定： 无</p>
        </li>
        <li>
            寄生构造函数模式

            基本思想是 创建一个函数， 该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。
        </li>
        <li>
            稳妥构造函数模式
            稳妥对象: 指的是没有公共属性，而且方法也不引用this对象。 稳妥对象适合在一些安全环境中（禁止使this和new），或者防止数据被其他应用程序改动时使用。
            <p>稳妥构造函数模式 和 寄生构造函数模式的区别：</p>
            <p>1. 函数内不适用this</p>
            <p>2. 不适用new 操作符调用构造函数。</p>
        </li>
    </ol>
</body>

</html>